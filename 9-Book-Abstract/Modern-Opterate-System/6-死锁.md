- 《现代操作系统》读摘

# 死锁

- 指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

### 资源

##### 可抢占资源和不可抢占资源

- `可抢占资源`：可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占资源。
- `不可抢占资源`：在不引起相关的计算失败的情况下，无法把它从占有它的进程处抢占过来。
- `请求资源 ==> 使用资源 ==> 释放资源`

##### 资源获取

- 使用信号量保护资源
```cpp
// 一个资源
# include <iostream>
using namespace std;
typedef int semaphore;
void process_A(void){
    down(&resource_1);
    use_resource_1();
    up(&resource_1);
}
// 两个资源
# include <iostream>
using namespace std;
typedef int semaphore;
semaphore semaphore_1;
semaphore semaphore_2;
void process_A(void){
    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_2);
    up(&resource_1);
}
```

```cpp
// 无锁的编码
#include<iostream>
using namespace std;
typedef int semaphore;
semaphore resource_1;
semaphore resource_2;
void process_A(void){
    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_2);
    up(&resource_1);
}
void process_B(void){
    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_2);
    up(&resource_1);
}
// 有可能出现死锁的编码
semaphore resource_1;
semaphore resource_2;
void process_A(void){
    down(&resource_1);
    down(&resource_2);
    use_both_resources();
    up(&resource_2);
    up(&resource_1);
}
void process_B(void){
    down(&resource_2);
    down(&resource_1);
    use_both_resources();
    up(&resource_1);
    up(&resource_2);
}
```

### 死锁简介

- 如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的
- `资源死锁`

##### 资源死锁的条件

- 互斥条件
- 占有和等待条件
- 不可抢占条件
- 环路等待条件

##### 死锁建模

- 产生环路导致死锁
- 对于一个有可能引起死锁的资源请求，操作系统可以干脆不批准请求，并把该进程挂起（即不参与调度）一直到处于安全状态为止
- 处理死锁策略：
  1. 忽略该问题
  2. 监测死锁并恢复
  3. 仔细对资源进行分配，动态地避免死锁
  4. 通过破坏引起死锁的四个必要条件之一，防止死锁发生

### 鸵鸟算法

- 把头埋在沙子里，假装根本没有问题发生

### 死锁检测和死锁恢复

##### 每种类型一个资源的死锁检测

- 检测有向无环图的方法
- 算法是依次将每个节点作为一棵树的根节点，并进行深度优先搜索。如果碰到已经遇到过的节点，那么就算找到了一个环。如果从任何给定的节点出发的弧都被穷举了，那么就回溯到前面的节点。如果回溯到根并且不能再深入下去，那么从当前节点出发的子图中就不包含任何环。如果所有的节点都是如此，那么整个图就不存在换，也就是说系统不存在死锁。

##### 每种类型多个资源的死锁检测

- 恒等式：
  - $\sum_{i=i}^n C_{ij} + A_j = E_j$
    - E—现有资源向量
    - A—可用资源向量
    - C—当前分配矩阵
    - R—请求矩阵
  - 检测算法如下：
    1. 寻找一个没有标记的进程$P_i$，对于它而言R矩阵的第i行向量小于或等于A
    2. 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第1步
    3. 如果没有这样的进程，那么算法终止

##### 从死锁中恢复

- `利用抢占恢复`
- `利用回滚恢复`
  - 周期性地对进程进行`检查点检查`
- `通过杀死进程恢复`
  - 杀掉环中的一个进程
  - 选一个环外的进程作为牺牲品以释放该进程的资源
  - 最好杀死可以从头开始重新运行而且不会带来副作用的进程

### 死锁避免

##### 资源轨迹图

##### 安全状态和不安全状态

##### 单个资源的银行家算法

- 在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
- 安全和不安全的状态
  - 如果所有过程有可能完成执行（终止），则一个状态（如上述范例）被认为是安全的。由于系统无法知道什么时候一个过程将终止，或者之后它需要多少资源，系统假定所有进程将最终试图获取其声明的最大资源并在不久之后终止。在大多数情况下，这是一个合理的假设，因为系统不是特别关注每个进程运行了多久（至少不是从避免死锁的角度）。此外，如果一个进程终止前没有获取其它能获取的最多的资源，它只是让系统更容易处理。
  - 基于这一假设，该算法通过尝试寻找允许每个进程获得的最大资源并结束（把资源返还给系统）的进程请求的一个理想集合，来决定一个状态是否是安全的。不存在这个集合的状态都是不安全的。
- 伪代码
  - P - 进程的集合
  - Mp - 进程p的最大的请求数目
  - Cp - 进程p当前被分配的资源
  - A - 当前可用的资源
```cpp
while (P != ∅) {
    found = FALSE;
    foreach (p ∈ P) {
        if (Mp − Cp ≤ A) {
             /* p可以獲得他所需的資源。假設他得到資源後執行；執行終止，並釋放所擁有的資源。*/
             A = A + Cp ;
             P = P − {p};
             found = TRUE;
        }
    }
    if (! found) return FAIL;
}
return OK;
```
- [wik关于银行家算法的链接](https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)

##### 多个资源的银行家算法

### 死锁预防

| 条件 | 处理方式 |
| :-: | :-: |
| 互斥 | 一切都是用假脱机技术 |
| 占有和等待 | 在开始就请求全部资源 |
| 不可抢占 | 抢占资源 |
| 环路等待 | 对资源按序编号 |

##### 破坏互斥条件

- 如果进程不被一个进程所独占，那么死锁肯定不会产生
- 避免分配拿下不是绝对必须的资源，尽量做到可能少的进程可以真正请求资源

##### 破坏占有并等待条件

- 只有禁止已持有资源的进程再等待其他资源便可以消除死锁
- 两种方法：
  1. 实现方法是规定所有进程在开始执行前请求所需的全部资源
  2. 要求当一个进程求情资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源

##### 破坏不可抢占条件

- 通过虚拟化的方式

##### 破坏环路等待条件

- 保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，它必须先释放第一个资源
- 将所有资源编号，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出

### 其他问题

##### 两阶段加锁

- 思想：
  - 在第一阶段，进程试图对所有所需的记录进行加锁，一次锁一个记录
  - 如果第一阶段加锁成功，就开始第二阶段，完成更新然后释放锁。如果第一阶段没有加锁成功，就重新开始第一阶段。

##### 通信加锁

- 资源死锁是`竞争性同步`的问题
- 在通信系统中（比如说网络），即两个或两个以上进程利用发送信息来通信时。一种普遍的情形是进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A将阻塞以等待回复，而B会阻塞等待一个向其发送命令的请求，因此发生死锁。
- 在一系列进程中，每个进程因为等待另外一个进程引发的事件而发生阻塞，就是一种死锁。
- 通信死锁是`协同同步`的异常情况，处于这种死锁中的进程如果是各自独立执行的，则无法完成任务。

##### 活锁

- 礼貌的进程可能导致活锁
```cpp
#include<iostream>
using namespace std;
void process_A(void){
    acquire_lock(&resource_1);
    while(try_lock(&resource_2) == FALL){
        release_lock(&resource_1);
        wait_fixed_time();
        acquire_lock(&resource_1);
    }
    use_both_resources();
    release_lock(&resource_2);
    release_lock(&resource_1);
}

void process_B(void){
    acquire_lock(&resource_2);
    while(try_lock(&resource_1) == FALL){
        release_lock(&resource_2);
        wait_fixed_time();
        acquire_lock(&resource_2);
    }
    use_both_resources();
    release_lock(&resource_1);
    release_lock(&resource_2);
}
```

##### 饥饿

### 有关死锁的研究

- 

### 小结

- 银行家算法可以通过拒绝可能引起不安全状态的请求来避免死锁
- 活锁和死锁的问题相似，那就是它也可以停止所有的转发进程，但是二者在技术上不同，由于活锁包含了一些实际上并没有锁住的进程，因此可以通过先来先服务的分配策略来避免饥饿

***

